class QuadTree{constructor(t,n=4,i=8){this.bounds=t,this.maxPoints=n,this.maxDepth=i,this.points=[],this.children=null,this.depth=0}insert(t){if(!this.contains(t))return!1;if(null===this.children&&this.points.length<this.maxPoints)return this.points.push(t),!0;if(null===this.children&&this.depth<this.maxDepth&&this.subdivide(),null!==this.children){for(let n of this.children)if(n.insert(t))return!0}else this.points.push(t);return!0}subdivide(){const{minLat:t,maxLat:n,minLng:i,maxLng:s}=this.bounds,e=(t+n)/2,a=(i+s)/2;this.children=[new QuadTree({minLat:t,maxLat:e,minLng:i,maxLng:a},this.maxPoints,this.maxDepth),new QuadTree({minLat:e,maxLat:n,minLng:i,maxLng:a},this.maxPoints,this.maxDepth),new QuadTree({minLat:t,maxLat:e,minLng:a,maxLng:s},this.maxPoints,this.maxDepth),new QuadTree({minLat:e,maxLat:n,minLng:a,maxLng:s},this.maxPoints,this.maxDepth)];for(let t of this.children)t.depth=this.depth+1;for(let t of this.points)for(let n of this.children)if(n.insert(t))break;this.points=[]}contains(t){const{minLat:n,maxLat:i,minLng:s,maxLng:e}=this.bounds;return t.lat>=n&&t.lat<=i&&t.lng>=s&&t.lng<=e}query(t){const n=[];if(!this.intersects(t))return n;for(let i of this.points)this.pointInBounds(i,t)&&n.push(i);if(this.children)for(let i of this.children)n.push(...i.query(t));return n}intersects(t){const{minLat:n,maxLat:i,minLng:s,maxLng:e}=this.bounds,{minLat:a,maxLat:h,minLng:l,maxLng:r}=t;return!(h<n||a>i||r<s||l>e)}pointInBounds(t,n){const{minLat:i,maxLat:s,minLng:e,maxLng:a}=n;return t.lat>=i&&t.lat<=s&&t.lng>=e&&t.lng<=a}clear(){this.points=[],this.children=null}}class ClusterEngine{constructor(t=[]){this.allPoints=t,this.quadTree=null,this.buildIndex()}buildIndex(){if(0===this.allPoints.length)return;const t=this.allPoints.map((t=>t.lat)),n=this.allPoints.map((t=>t.lng)),i=Math.min(...t),s=Math.max(...t),e=Math.min(...n),a=Math.max(...n),h=.01;this.quadTree=new QuadTree({minLat:i-h,maxLat:s+h,minLng:e-h,maxLng:a+h},6,10);for(let t of this.allPoints)this.quadTree.insert({lat:t.lat,lng:t.lng,data:t,id:t.id})}updatePoints(t){this.allPoints=t,this.quadTree=null,this.buildIndex()}getClusterRadiusForZoom(t,n=0){return t>=14&&n<300?-1:t>=16?0:t>=14?.01:t>=12?.03:t>=10?.1:t>=8?.2:.5}computeClusters(t,n){const i=this.quadTree.query(n),s=this.getClusterRadiusForZoom(t,i.length);if(-1===s){const t=i.map((t=>t.data));return{clusters:[],visiblePoints:t,allPointsInBounds:t,isClustered:!1}}const e=s/Math.cos((n.minLat+n.maxLat)/2*Math.PI/180),a=[],h=new Set,l=[];for(let t of i){if(h.has(t.id))continue;const n=i.filter((n=>!h.has(n.id)&&Math.abs(n.lat-t.lat)<=s&&Math.abs(n.lng-t.lng)<=e));if(n.length>1){const i=n.map((t=>t.data)),s=i.filter((t=>{const n=Number(t.lat),i=Number(t.lng);return isFinite(n)&&isFinite(i)}));if(0===s.length){h.add(t.id);continue}const e=s.reduce(((t,n)=>t+Number(n.lat)),0)/s.length,l=s.reduce(((t,n)=>t+Number(n.lng)),0)/s.length;a.push({id:`cluster_${a.length}`,lat:e,lng:l,count:s.length,points:i});for(let t of n)h.add(t.id)}else h.add(t.id)}for(let t of i)h.has(t.id)||l.push(t.data);return{clusters:a,visiblePoints:l,allPointsInBounds:i.map((t=>t.data)),isClustered:!0}}static haversineDistance(t,n,i,s){const e=Math.PI/180,a=(i-t)*e,h=(s-n)*e,l=Math.sin(a/2)**2+Math.cos(t*e)*Math.cos(i*e)*Math.sin(h/2)**2;return 6371*(2*Math.atan2(Math.sqrt(l),Math.sqrt(1-l)))}}export{QuadTree,ClusterEngine};