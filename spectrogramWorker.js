let canvas,ctx,sampleRate=44100,windowCache=new Map,twiddleFactorCache=new Map,bufferPool=new Map,bitReverseCache=new Map,colorMapUint=null,resampleMapCache=new Map,currentOptions={colorMap:null,windowFunc:"hann",gainDB:20,rangeDB:80};function renderSpectrogram(t,e,a,o,n={}){const r=Math.max(1,Math.floor(a*(1-o/100))),c=Math.max(1,Math.ceil((t.length-a)/r)),s=a/2;canvas.width=c,canvas.height=s;const l=ctx.createImageData(c,s),i=l.data,f=getWindowCached(a),{real:h,imag:p}=getBuffersCached(a),d=getBitReverseCached(a),M=getTwiddleFactorsCached(a);for(let e=0,o=0;o+a<=t.length;o+=r,e++){for(let e=0;e<a;e++)h[e]=t[o+e]*f[e],p[e]=0;fftOptimized(h,p,M,d);for(let t=0;t<s;t++){const a=h[t]*h[t]+p[t]*p[t],o=Math.sqrt(a);let n=o>1e-12?Math.log10(o)/5:-2.4;n=n<0?0:n>1?1:n;const r=Math.floor(255*n),l=4*((s-1-t)*c+e);if(colorMapUint){const t=4*r;i[l]=colorMapUint[t],i[l+1]=colorMapUint[t+1],i[l+2]=colorMapUint[t+2],i[l+3]=colorMapUint[t+3]}else i[l]=r,i[l+1]=r,i[l+2]=r,i[l+3]=255}}ctx.putImageData(l,0,0),self.postMessage({type:"rendered"})}function getWindowCached(t){return windowCache.has(t)||windowCache.set(t,hannWindow(t)),windowCache.get(t)}function getTwiddleFactorsCached(t){if(!twiddleFactorCache.has(t)){const e=new Array(Math.log2(t));for(let a=0;a<Math.log2(t);a++){const t=1<<a+1,o=t>>1;e[a]=[];for(let n=0;n<o;n++){const o=-2*Math.PI*n/t;e[a][n]={c:Math.cos(o),s:Math.sin(o)}}}twiddleFactorCache.set(t,e)}return twiddleFactorCache.get(t)}function setColorMapUint(t){if(!t||!t.length)return void(colorMapUint=null);const e=new Uint8ClampedArray(1024);for(let a=0;a<256;a++){const o=t[a]||[0,0,0,1];e[4*a]=Math.round(255*(o[0]||0)),e[4*a+1]=Math.round(255*(o[1]||0)),e[4*a+2]=Math.round(255*(o[2]||0)),e[4*a+3]=Math.round(255*(null==o[3]?1:o[3]))}colorMapUint=e}function getResampleMap(t,e){const a=`${t}:${e}`;if(resampleMapCache.has(a))return resampleMapCache.get(a);const o=new Array(e),n=1/t,r=1/e;for(let a=0;a<e;a++){const e=[];for(let o=0;o<t;o++){const t=o*n,c=t+n,s=a*r,l=s+r,i=Math.max(0,Math.min(c,l)-Math.max(t,s));i>0&&e.push([o,i/r])}o[a]=e}return resampleMapCache.set(a,o),o}function getBuffersCached(t){return bufferPool.has(t)||bufferPool.set(t,{real:new Float32Array(t),imag:new Float32Array(t)}),bufferPool.get(t)}function getBitReverseCached(t){if(!bitReverseCache.has(t)){const e=Math.log2(t),a=new Uint32Array(t);for(let o=0;o<t;o++){let t=o,n=0;for(let a=0;a<e;a++)n=n<<1|1&t,t>>=1;a[o]=n}bitReverseCache.set(t,a)}return bitReverseCache.get(t)}function hannWindow(t){const e=new Float32Array(t),a=1/(t-1),o=2*Math.PI;for(let n=0;n<t;n++)e[n]=.5*(1-Math.cos(o*n*a));return e}function fftOptimized(t,e,a,o){const n=t.length;if(o)for(let a=0;a<n;a++){const n=o[a];if(n>a){let o=t[a];t[a]=t[n],t[n]=o,o=e[a],e[a]=e[n],e[n]=o}}else{let a=0;for(let o=1;o<n-1;o++){let r=n>>1;for(;a>=r;)a-=r,r>>=1;if(a+=r,a>o){let n=t[o];t[o]=t[a],t[a]=n,n=e[o],e[o]=e[a],e[a]=n}}}for(let o=0;o<a.length;o++){const r=a[o],c=1<<o+1,s=c>>1;for(let a=0;a<s;a++){const{c:o,s:l}=r[a];for(let r=a;r<n;r+=c){const a=r+s,n=o*t[a]-l*e[a],c=o*e[a]+l*t[a];t[a]=t[r]-n,e[a]=e[r]-c,t[r]+=n,e[r]+=c}}}}function fft(t,e){const a=t.length;let o,n,r,c,s,l,i,f=0,h=0;for(h=1,f=0;h<a-1;h++){for(o=a>>1;f>=o;)f-=o,o>>=1;f+=o,h<f&&(l=t[h],t[h]=t[f],t[f]=l,l=e[h],e[h]=e[f],e[f]=l)}o=0,n=1;for(let p=0;p<Math.log2(a);p++)for(o=n,n<<=1,r=0,h=0;h<o;h++)for(c=Math.cos(-2*Math.PI*h/n),s=Math.sin(-2*Math.PI*h/n),f=h;f<a;f+=n){const a=f+o;l=c*t[a]-s*e[a],i=s*t[a]+c*e[a],t[a]=t[f]-l,e[a]=e[f]-i,t[f]+=l,e[f]+=i}}self.onmessage=t=>{const{type:e}=t.data;if("init"===e)canvas=t.data.canvas,sampleRate=t.data.sampleRate||sampleRate,ctx=canvas.getContext("2d"),t.data.options&&(currentOptions=Object.assign({},currentOptions,t.data.options),currentOptions.colorMap&&setColorMapUint(currentOptions.colorMap));else if("setOptions"===e)currentOptions=Object.assign({},currentOptions,t.data.options||{}),t.data.options&&t.data.options.colorMap&&setColorMapUint(t.data.options.colorMap);else if("render"===e){if(!ctx)return;const e=Object.assign({},currentOptions,t.data.options||{});e.colorMap&&setColorMapUint(e.colorMap),renderSpectrogram(t.data.buffer,t.data.sampleRate||sampleRate,t.data.fftSize||1024,t.data.overlap||0,e)}};